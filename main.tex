\documentclass[journal,article,submit,moreauthors,pdftex,10pt,a4paper]{mdpi}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{verbatim}
\usepackage{float}

\usepackage[portuguese]{babel}

\usepackage[nomain, acronym, symbols]{glossaries}

\loadglsentries{acronyms}

\definecolor{cadmiumgreen}{rgb}{0.0, 0.42, 0.24}
\definecolor{burntorange}{rgb}{0.8, 0.33, 0.0}

\newcommand{\ct}[1]{{\color{black}#1}}
\newcommand{\odo}[1]{{\color{black}#1}}
\newcommand{\gus}[1]{{\color{black}#1}}
\newcommand{\cris}[1]{{\color{black}#1}}

\firstpage{1}
\makeatletter
\setcounter{page}{\@firstpage}

\makeatother

\Title{Escalonador Adaptativo para Sistemas Operacionais de Tempo Real \textit{Multicore} guiado por Aprendizado de
Máquina}

\begin{document}

\section{Introdução e Motivação}

\gls{rtos} são sistemas desenvolvidos para o processamento de tarefas com restrições temporais, onde deve-se assegurar
que os prazos de conclusão das tarefas sejam cumpridos. É possível classificar esses sistemas como críticos ou não
críticos conforme as suas aplicações e requisitos. \gls{rtos} críticos são utilizados em contextos onde a perda de
prazo na execução de tarefas pode ter consequências graves, o que inclui sistemas industriais, veículos autônomos,
sistemas de navegação de aeronaves e outros. Já em \gls{rtos} não-críticos, a perda de prazos pode ser tolerada, sendo
que os seus casos de uso envolvem sistemas de multimídia e processamento de áudio \cite[13--22]{kopetz2022real}.

As tarefas a serem executadas podem ter tempos de execução, prazos e requisitos de recursos computacionais variados,
sendo assim, são utilizados escalonadores que definem prioridades para cada tarefa de modo a ordená-las de uma forma em
que todas as restrições temporais sejam satisfeitas. Os escalonadores que a definem as prioridades antes da execução do
sistema são denominados estáticos, enquanto os que definem as prioridades durante o tempo de execução são considerados
dinâmicos \cite[247--248]{kopetz2022real}.

Atualmente, diversas arquiteturas de processadores são \textit{multicore}, permitindo o paralelismo na execução de
tarefas. A complexidade dessas arquiteturas introduz novos desafios na implementação de escalonadores de tempo real. O
compartilhamento de recursos, como a memória, \textit{cache} ou Entrada/Saída, por exemplo, pode afetar o tempo de
execução das tarefas de forma não determinística \cite{aceituno2023optimized}. Além disso, há problemas relacionados à
otimização e utilização eficiente dos recursos, como o balanceamento de carga entre núcleos ou a otimização no consumo
de energia do sistema \cite{jadon2024comprehensive, baital2024energy}.

Considerando este cenário, diferentes técnicas de escalonamento foram propostas nos últimos anos. Algumas técnicas
utilizam heurísticas, como algoritmos genéticos, para otimizar o desempenho do sistema. Há também a aplicação de
\gls{ml}, principalmente com técnicas de \gls{rl} \cite{hassan2025optimizing, liang2024adaptive}.

Propõe-se então o desenvolvimento de um escalonador dinâmico adaptativo para \gls{rtos} \textit{multicore} que seja
guiado por \gls{ml}, visando a otimização do desempenho. A política de priorização das tarefas seria definida com base
na inferência feita pelo algoritmo de \gls{ml} sobre a evolução temporal do estado do sistema. Isso permitiria que as
tarefas sejam executadas de uma forma que considere as variações de carga, perdas de prazo e outros fatores relevantes
que afetam o tempo de execução.

\section{Objetivos}

O objetivo principal deste trabalho é investigar e desenvolver um algoritmo de escalonamento informado por \gls{ml}
para \gls{rtos} \textit{multicore}, buscando aprimorar o desempenho do sistema e contribuir para o estado da arte da
aplicação de \gls{ml} em \gls{rtos}.

\subsection{Objetivos específicos}

\begin{itemize}
    \item Realizar uma revisão sistemática sobre a aplicação de \gls{ml} em \gls{rtos};
    \item Desenvolver um modelo de \gls{ml} para a inferência do estado do sistema;
    \item Desenvolver o algoritmo de escalonamento, utilizando o modelo treinado para informar o algoritmo;
    \item Validar a solução proposta, avaliando seu desempenho e \textit{overhead} sob diversos cenários de teste;
    \item Analisar os resultados obtidos, comparando a solução com o estado da arte.
\end{itemize}

\section{Estado da Arte}

No cenário de escalonamento para \gls{rtos} \textit{multicore}, diversas propostas buscam solucionar problemas
pertinentes, muitas delas focando em sistemas críticos em ambientes embarcados \cite{ismael2021scheduling}. Um dos
desafios relevantes é a mitigação da interferência entre tarefas, originada pelo compartilhamento de recursos. Embora
soluções de escalonamento tenham sido propostas para resolver esse problema, elas ainda encontram-se limitadas
\cite{lugo2022survey}. Além disso, a distribuição eficiente da carga de trabalho entre os núcleos também é um problema
investigado. Contudo, muitas das soluções propostas para o balanceamento de carga ainda são limitadas por problemas
como a heterogeneidade das arquiteturas, escalabilidade, dinamicidade das cargas de trabalho e \textit{overheads}
inerentes à complexidade dos escalonadores \cite{jadon2024comprehensive}.

Com a utilização de sistemas de tempo real em ambientes embarcados com fontes limitadas de energia, a eficiência
energética se tornou um tópico relevante na área. Nesse contexto, são utilizados em algoritmos técnicas que envolvem
\gls{dvfs} e também heurísticas para minimizar o consumo de energia \cite{chniter2020improved, antolak2021energy}.

A aplicação de \gls{ml} no contexto de escalonamento \textit{multicore} foca em vários objetivos, como, por exemplo, na
otimização do escalonamento através de \gls{rl} e também na aplicação de \gls{drl} para a otimização do escalonamento
em arquiteturas heterogêneas \cite{liang2024adaptive, tan2024deep}. A eficiência energética também é um dos focos,
sendo que vários trabalhos propostos nessa linha utilizam \gls{ml}, aplicando \gls{drl}, redes de \gls{lstm}, regressão
linear e \glspl{cnn} \cite{peng2024energy, allaqband2024efficient, khan2025enhanced}. De modo geral, essas soluções
aplicam \gls{ml} para modelar o comportamento do sistema e das aplicações, analisando dados como contadores de
desempenho, características das tarefas e suas dependências. A partir disso, são tomadas as decisões relacionadas ao
escalonamento ou outros aspectos.

Além do escalonamento, \gls{ml} também é utilizado em contextos mais gerais de otimização e gerenciamento de eficiência
energética e temperatura \cite{pagani2018machine}. Por fim, há estudos que demonstram a viabilidade da aplicação de
\gls{ml} em \gls{rtos} de forma não intrusiva e eficiente \cite{hoffmann2021online, horstmann2019framework}. Em geral,
ainda há espaço para avançar com soluções que utilizam modelos mais explicáveis e generalistas quanto a arquiteturas
\textit{multicore}.

\section{Contribuições}

Considerando o estado da arte, esse trabalho contribuirá com o desenvolvimento de um escalonador adaptativo guiado
por um modelo de \gls{ml} que possa operar eficientemente sob cenários mais complexos com cargas de trabalho variadas.
Graças a técnicas de implementação e coleta de dados não disruptivas, é esperado que essa solução tenha um
\textit{overhead} baixo \cite{horstmann2019framework, passig2023monitoring}. Adicionalmente, o trabalho oferecerá uma
revisão aprofundada do estado da arte de algoritmos de escalonamento guiados por \gls{ml}.

\section{Metodologia}

O projeto se trata de uma pesquisa aplicada e será iniciado com uma pesquisa exploratória, visando o desenvolvimento da
fundamentação teórica e o estabelecimento do estado da arte. A implementação prática se baseará nos fundamentos do
\textit{framework} de \citet{horstmann2019framework} e utilizará o \gls{rtos} \gls{epos} \cite{epos}. Inicialmente,
será feito um estudo sobre as métricas e dados relevantes a serem incluídos no treinamento do modelo. Posteriormente,
uma estratégia de treinamento e arquitetura serão definidas, seguidas por uma validação preliminar do modelo antes do
avanço para a próxima etapa. Em sequência, o escalonador será implementado com a integração do modelo treinado para
a captura do estado do sistema. Por fim, a solução será testada experimentalmente e os resultados serão analisados e
documentados.

\newpage

\bibliography{references}

\end{document}
